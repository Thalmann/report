% !TEX root = ../master.tex

\section{The Decentralized Label Model}
% labels (owner,reader, no writer yet)
% at most as restrictive definition
% label join
% relabeling
% implicit flow
% acts_for, declassify methods
% implicit labels
The Decentralized Label Model \cite{myers1997, myers1998, myers2000} is a method of ensuring information flow control in a system.
This is done by annotating the source code with security policies, in the form of labels attached to data-holding constructs.
This section will present the necessary information needed to understand the first implementation of \thetool.
The descriptions and definitions in this section are based on \cite{myers1997, myers1998, myers2000}, but only relevant parts will be presented now.
Throughout the examples, we will use the same grammar as that used by \thetool.

\subsection{Labels and Policies}
Throughout a program, values are declared, initialized, and assigned to variables and other value-holders.
Value-holders are collectively known as \emph{slots}, which cover constructs such as variables, structs, return values, and other storage locations.
In order to ensure that a certain assignment is legal, such that no information is unintentionally leaked, we assign \emph{labels} to these value-holders so that they can be compared.
This way we can ensure that an assignment is only legal in the cases where higher-security values aren't assigned to lower-security slots.

For any slot, we can attach a label $L$, which is a set of \emph{policies}.
It is possible to define both read (privacy) and write (integrity) policies, however, we will leave out write policies for now.
Each policy contains an owner $o$ and a set of readers $r_1,r_2,\dots,r_n$.
Then, for each label $L$ we have a set of owners, denoted $owners(L)$ and for each $o \in owners(L)$ we have a reader set, denoted $readers(L, o)$.

\begin{example}{A label with two policies}\label{dlm:ex:simple_label}
  \texttt{int \{\{o1<-r1,r2; o2<-r2,r3\}\} x = 0;}
\end{example}

\subsection{Principals}
In the above description, we saw examples of \textit{principals}.
Both the owners and readers of a policy are considered principals.
In short, principals represent either real-world users or the authority under which programs are run.
It is also possible to defined principal hierarchies, so that we can describe more complex principal relationships, such as groups or roles.
However, principal hierarchies will be left out for now.

\subsubsection{The effective reader set}
Having multiple owners, where each owner defining its own policy, enables the individual owner to ensure that ``shared'' data isn't redistributed without all owners' consent.
This also means that we need to determine the \emph{effective reader set}, which is the set of readers that all owners agree upon.
Thus, the effective reader set is the intersection of the readers defined in each policy.
For the label in \cref{dlm:ex:simple_label}, the effective reader set is $\{r2\}$ $= \{r1,r2\} \cap \{r2, r3\}$.

\subsubsection{Label comparison}
In order to check that security policies are enforced throughout a program, we need to be able to compare the labels.
The property of labels that we want to compare is their \emph{restrictiveness}.
We will use the simple, and more strict, definition, as we for the moment will not take into account the principal hierarchies.
The ``at most as restrictive as'' $\sqsubseteq$ is defined as follows:

\begin{equation}
  \begin{split}
    \text{For } L_1 \sqsubseteq L_2 \text{ we have that}\\
    owners(L_1) \subseteq owners(L_2) \text{ and}\\
    \forall o \in owners(L_1), readers(L_1, o) \supseteq readers(L_2, o)
  \end{split}
\end{equation}
