% !TEX root = ../master.tex

\section{The Decentralized Label Model}
The Decentralized Label Model \cite{myers1997, myers1998, myers2000} is a method of ensuring information flow control in a system.
This is done by annotating the source code with security policies, in the form of labels attached to data-holding constructs.
This section will present the necessary information needed to understand the first implementation of \thetool.
The descriptions and definitions in this section are based on \cite{myers1997, myers1998, myers2000}, but only relevant parts will be presented now.
Throughout the examples, we will use the same grammar as that used by \thetool.

\subsection{Labels and Policies}
Throughout a program, values are declared, initialized, and assigned to variables and other value-holders.
Value-holders are collectively known as \emph{slots}, which cover constructs such as variables, structs, return values, and other storage locations.
In order to ensure that a certain assignment is legal, such that no information is unintentionally leaked, we assign \emph{labels} to these value-holders so that they can be compared.
This way we can ensure that an assignment is only legal in the cases where higher-security values aren't assigned to lower-security slots.

For any slot, we can attach a label $L$, which is a set of \emph{policies}.
It is possible to define both read (privacy) and write (integrity) policies, however, we will leave out write policies for now.
Each policy contains an owner $o$ and a set of readers $r_1,r_2,\dots,r_n$.
Then, for each label $L$ we have a set of owners, denoted $owners(L)$ and for each $o \in owners(L)$ we have a reader set, denoted $readers(L, o)$.

\begin{example}{A label with two policies}\label{dlm:ex:simple_label}
  \texttt{int \{\{o1->r1,r2; o2->r2,r3\}\} x = 0;}
\end{example}

\subsubsection{Principals}
In the above description, we saw examples of \textit{principals}.
Both the owners and readers of a policy are considered principals.
In short, principals represent either real-world users or the authority under which programs are run.
It is also possible to defined principal hierarchies, so that we can describe more complex principal relationships, such as groups or roles.
However, principal hierarchies will be left out for now.

\subsubsection{The effective reader set}
Having multiple owners, where each owner defining its own policy, enables the individual owner to ensure that ``shared'' data isn't redistributed without all owners' consent.
This also means that we need to determine the \emph{effective reader set}, which is the set of readers that all owners agree upon.
Thus, the effective reader set is the intersection of the readers defined in each policy.
For the label in \cref{dlm:ex:simple_label}, the effective reader set is $\{r2\}$ $= \{r1,r2\} \cap \{r2, r3\}$.

\subsubsection{Label comparison}
In order to check that security policies are enforced throughout a program, we need to be able to compare the labels.
The property of labels that we want to compare is their \emph{restrictiveness}.
We will use the simple, and more strict, definition\cite{myers1997}, as we for the moment will not take into account the principal hierarchies.
The ``at most as restrictive as'' $\sqsubseteq$ is defined as follows:

\begin{definition}{Label Comparison Rule}
  For $L_1 \sqsubseteq L_2$, we have that
  $owners(L_1) \subseteq owners(L_2)$ and\\
  $\forall o, o \in owners(L_1), readers(L_1, o) \supseteq readers(L_2, o)$
\end{definition}

\subsubsection{Label join}
In order to compare composite labels, such as those for arithmetical expressions, we need to be able to create and use a ``joined label''.
This is also needed when we consider implicit flows via scope blocks, as will be described in the following section.
The result of a label join is the least restrictive label that maintains all flow restrictions.
Since each label is a set of policies, the definition of label join $\sqcup$ is simply:

\begin{definition}{Label Join Rule}
  $L_1 \sqcup L_2 = L_1 \cup L_2$
\end{definition}

\begin{example}{Joining of two labels}
  If we have the two initializations:\\
  \texttt{int \{\{a->z,y\}\} val1 = 4;}\\
  \texttt{int \{\{b->x,w\}\} val2 = 8;}\\[1em]
  The joined label of the expression\\
   \texttt{val1 + val2}\\
   is\\
   \texttt{\{\{a->z,y\}\} JOIN \{\{b->x,w\}\}}\\
   which is equal to\\
   \texttt{\{\{a->z,y;b->x,w\}\}}.
\end{example}

\subsection{Implicit flows}
\newcommand{\dlmpc}{$\underline{pc}$}
When assigning a value to a slot, possibly from another slot, it is an explicit flow.
It is also possible to have implicit flows throughout a program due to control structures, such as loops and conditionals in general.
For whatever assignments we would do inside a block (or within a deeper block hierarchy) we need to take the predicates of these blocks into consideration.
This is done by adding the concept of \emph{program counter labels}, denoted \dlmpc.
For each scope we will have an implicit \dlmpc, depending on the surrounding predicates' labels.
